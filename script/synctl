#!/usr/bin/perl -l

use strict;
use warnings;

use Getopt::Long qw(GetOptionsFromArray);
use Text::ParseWords;

use Synctl qw(:verbose);
use Synctl::Util::Config;
use Synctl::Util::Status;
use Synctl::Profile;
use Synctl::Verbose;


my %MAINS = (
    'fsck'   => \&fsck_main,
    'help'   => \&help_main,
    'init'   => \&init_main,
    'list'   => \&list_main,
    'send'   => \&send_main,
    'recv'   => \&recv_main,
    'rm'     => \&rm_main,
    'serve'  => \&serve_main,
    'status' => \&status_main,
    );

my %MANPAGES = (
    'fsck'   => 'synctl-fsck',
    'help'   => 'synctl-help',
    'init'   => 'synctl-init',
    'list'   => 'synctl-list',
    'send'   => 'synctl-send',
    'recv'   => 'synctl-recv',
    'rm'     => 'synctl-rm',
    'serve'  => 'synctl-serve',
    'status' => 'synctl-status',
    );

my %INFOS = (
    'fsck'   => 'verify and repair server content',
    'help'   => 'obtain some help for a command',
    'init'   => 'initialize a local server',
    'list'   => 'list the snapshots of a given server',
    'send'   => 'send files to create a new snapshot',
    'recv'   => 'receive files from a given snapshot',
    'rm'     => 'remove snapshots of a given server',
    'serve'  => 'serve ssh forwared requests',
    'status' => 'display synchronization status of local files',
    );


my $PROGRAM = 'synctl';
my $COMMAND = '';

my @PROFILE_PATH = qw(. ~/.config/synctl /etc/synctl);

my $VERBOSE = WARN;


sub error
{
    my ($message, $exitcode) = @_;

    if (!defined($message)) {
	$message = 'undefined error';
    }
    if (!defined($exitcode)) {
	$exitcode = 255;
    }

    printf(STDERR "%s%s: %s\n", $PROGRAM, $COMMAND, $message);
    printf(STDERR "Please type '%s --help' for more information\n", $PROGRAM);

    exit ($exitcode);
}

sub opterr
{
    my ($message) = @_;

    if ($message =~ /^Unknown option: (.*)$/) {
	error("unknown option '$1'");
    }

    printf(STDERR "%s", $message);
}

sub syncerr
{
    my ($code, @messages) = @_;
    my $message = join(': ', @messages);

    $code = lc($code);
    chomp($message);
    error("$code: $message");
}

sub verbose
{
    my ($opt, $val) = @_;
    my $effect;
    my %effects = (
	0 => 0,
	1 => ERROR,
	2 => WARN ,
	3 => Synctl::synthetic(),
	4 => INFO,
	5 => DEBUG
	);

    if ($val < 0) {
	$VERBOSE++;
    } else {
	$VERBOSE = $val;
    }

    $effect = $effects{$VERBOSE};
    if (!defined($effect)) {
	$effect = DEBUG;
    }

    if ($effect eq DEBUG) {
	Synctl::Configure(ERROR => undef);
    }
    Synctl::Configure(VERBOSE => $effect);
}

my %OPTIONS = (
    #                  [ Action       Profile Server Client Snapshots ]
    'C|directory=s' => [ sub { shift()->directory($_[1]) }, 0, 1, 1, 1 ],
    's|server=s'    => [ sub { shift()->server($_[1]) },    1, 1, 0, 1 ],
    'ssh-local=s'   => [ sub { shift()->sshlocal($_[1]) },  1, 1, 0, 1 ],
    'ssh-remote=s'  => [ sub { shift()->sshremote($_[1]) }, 1, 1, 0, 1 ],
    'c|client=s'    => [ sub { shift()->client($_[1]) },    1, 0, 1, 0 ],
    'i|include=s'   => [ sub { shift()->include($_[1]) },   1, 0, 1, 0 ],
    'e|exclude=s'   => [ sub { shift()->exclude($_[1]) },   1, 0, 1, 0 ],
    'o|older=s'     => [ sub { shift()->older($_[1]) },     0, 0, 0, 1 ],
    'n|newer=s'     => [ sub { shift()->newer($_[1]) },     0, 0, 0, 1 ],
    'r|reverse'     => [ sub { shift()->reversed($_[1]) },  0, 0, 0, 1 ],
    );

sub build_options
{
    my ($config, $id) = @_;
    my ($option, %options);

    foreach $option (keys(%OPTIONS)) {
	my $action;

	if ($OPTIONS{$option}->[$id] == 0) {
	    next;
	}

	if (!defined($action = $OPTIONS{$option}->[0])) {
	    next;
	}

	$options{$option} = sub { $action->($config, @_) };
    }

    return %options;
}

sub build_profile_options  { return build_options(shift(), 1); }
sub build_server_options   { return build_options(shift(), 2); }
sub build_client_options   { return build_options(shift(), 3); }
sub build_snapshot_options { return build_options(shift(), 4); }

sub use_profile
{
    my ($pname, $config) = @_;
    my ($profile);

    if (!@{$config->directory()}) {
	$config->directory(@PROFILE_PATH);
    }

    $config->multiset(sub {
	my ($old, $new) = @_;
	return $old;
    });

    $profile = $config->profile($pname);
    $profile->parse(build_profile_options($config));
}


sub help_list
{
    my @commands = sort { $a cmp $b } keys(%INFOS);
    my ($length, $command);

    $length = 0;
    foreach $command (@commands) {
	if (length($command) > $length) {
	    $length = length($command);
	}
    }

    return "List of the possible commands of $PROGRAM:\n"
	. join("", map { sprintf('  %-'. $length ."s  %s\n", $_,$INFOS{$_}) }
	       @commands);
}

sub help_main
{
    my ($command, @err);
    my ($manpage);

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	'l|list'   => sub { printf("%s", help_list()); exit (0); },
	);
    $SIG{__WARN__} = undef;

    ($command, @err) = @_;

    if (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    }

    if (defined($command)) {
	$manpage = $MANPAGES{$command};
	if (!defined($manpage)) {
	    error("unknown command '$command'");
	}

	exec ('man', $manpage);
	exit (1);
    }

    printf("%s", usage());
    exit (0);
}

sub init_main
{
    my ($path, @err);
    my ($force) = (0);

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	'f|force'      => \$force,
	'v|verbose:-1' => \&verbose
	);
    $SIG{__WARN__} = undef;

    ($path, @err) = @_;
    if (!defined($path)) {
	error('missing operand path');
    } elsif (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    }

    if ($force && (-e $path)) {
	system('rm', '-rf', $path);
	notify(INFO, IFDELET, $path);
    }

    Synctl::init($path);
    return 0;
}

sub list_main
{
    my ($pname, @err);
    my ($invert, @contains, $format, $date);
    my ($profile, @snapshots, $snapshot, $text, $path);
    my ($Y, $m, $d, $H, $M, $S, $u);
    my $config = Synctl::Util::Config->new();

    $format = "%u  %Y-%m-%d-%H-%M-%S";

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	build_snapshot_options($config),
	'c|contain=s'   => \@contains,
	'd|date=s'      => \$date,
	'i|invert'      => \$invert,
	'f|format=s'    => \$format,
	'v|verbose:-1'  => \&verbose,
	);
    $SIG{__WARN__} = undef;

    ($pname, @err) = @_;

    if (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    } elsif (defined($pname)) {
	use_profile($pname, $config);
    }

    @snapshots = $config->snapshots();

    if (defined($date)) {
	if (defined($invert)) {
	    @snapshots = grep {    $_->date() =~ /$date/   } @snapshots;
	} else {
	    @snapshots = grep { !( $_->date() =~ /$date/ ) } @snapshots;
	}
    }

    foreach $path (@contains) {
	@snapshots = grep {
	    defined($_->get_properties($path));
	} @snapshots;
    }

    foreach $snapshot (@snapshots) {
	$u = $snapshot->id();
	$snapshot->date() =~
	    m|^(\d{4})-(\d\d)-(\d\d)-(\d\d)-(\d\d)-(\d\d)$|;
	($Y, $m, $d, $H, $M, $S) = ($1, $2, $3, $4, $5, $6);

	$text = $format;
	$text =~ s|(%%)*%Y|$Y|g;
	$text =~ s|(%%)*%m|$m|g;
	$text =~ s|(%%)*%d|$d|g;
	$text =~ s|(%%)*%H|$H|g;
	$text =~ s|(%%)*%M|$M|g;
	$text =~ s|(%%)*%S|$S|g;
	$text =~ s|(%%)*%u|$u|g;
	printf("%s\n", $text);
    }

    return 0;
}

sub fsck_main
{
    my ($pname, @err);
    my ($controler, $profile);
    my $config = Synctl::Util::Config->new();

    $config->directory(@PROFILE_PATH);

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	build_server_options($config),
	);
    $SIG{__WARN__} = undef;

    ($pname, @err) = @_;

    if (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    } elsif (defined($pname)) {
	use_profile($pname, $config);
    }

    $controler = $config->controler();
    return $controler->fsck();
}

sub send_main
{
    my ($pname, @err);
    my ($controler, $seeker);
    my $config = Synctl::Util::Config->new();

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	build_client_options($config),
	build_server_options($config),
	'v|verbose:-1' => \&verbose,
	);
    $SIG{__WARN__} = undef;

    ($pname, @err) = @_;

    if (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    } elsif (defined($pname)) {
	use_profile($pname, $config);
    }

    notify(DEBUG, ICONFIG, 'filters',
	   '[' . join(', ', map { "'$_'" } @{$config->filters()}) . ']');

    if (defined($config->send())) {
	return 0;
    } else {
	return 1;
    }
}

sub recv_main
{
    my ($pname, $id, @err);
    my ($profile, $controler, $ndate, $snapshot, @snapshots);
    my $config = Synctl::Util::Config->new();

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	build_client_options($config),
	build_server_options($config),
	'v|verbose:-1' => \&verbose,
	);
    $SIG{__WARN__} = undef;

    ($pname, $id, @err) = @_;

    if (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    } elsif (defined($pname) && $pname ne '') {
	use_profile($pname, $config);
    }

    notify(DEBUG, ICONFIG, 'filters',
	   '[' . join(', ', map { "'$_'" } @{$config->filters()}) . ']');

    if (defined($id)) {
	$config->snapshotid($id);
    }

    if (defined($config->recv())) {
	return 0;
    } else {
	return 1;
    }
}

sub rm_main
{
    my ($pname, @ids);
    my ($force);
    my ($controler, $id, @snapshots, $answer);
    my $config = Synctl::Util::Config->new();

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	build_server_options($config),
	'f|force'       => \$force,
	'v|verbose:-1'  => \&verbose,
	);
    $SIG{__WARN__} = undef;

    if (defined($config->server())) {
	(@ids) = @_;
    } else {
	($pname, @ids) = @_;
	use_profile($pname);
    }

    if (!@ids) {
	error('missing snapshot operand');
    } else {
	$config->snapshotid(\@ids);
    }

    $controler = $config->controler();
    @snapshots = $config->snapshots();

    if (!@snapshots) {
	error('no matching snapshot');
    }

    if (!$force) {
	printf("Following snapshots will be removed:\n");
	foreach (@snapshots) {
	    printf("  %s  %s\n", $_->id(), $_->date());
	}
	printf("Are you sure [y/N] ? ");
	$| = 1;

	chomp($answer = <STDIN>);
	if (lc($answer) ne 'y') {
	    return 1;
	}
    }

    foreach (@snapshots) {
	notify(DEBUG, ICONFIG, 'snapshot', $_->id());
    }

    foreach (@snapshots) {
	$controler->delete($_);
    }

    return 0;
}

sub serve_main
{
    my ($path, @err) = @_;
    my $controler;

    if (!defined($path)) {
	error("missing server location");
    } elsif (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    }

    $controler = Synctl::controler($path);
    return Synctl::serve($controler);
}

sub status_main
{
    my ($pname, $path, @err);
    my ($seeker, %result, $entry, $remote, $snapshot, @snapshots);
    my $config = Synctl::Util::Config->new();
    my $status = Synctl::Util::Status->new();
    my $color = 'auto';

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('permute');
    GetOptionsFromArray(
	\@_,
	build_client_options($config),
	build_server_options($config),
	'a|all'        => sub { $status->all(1); },
	'color=s'      => \$color,
	'p|porcelain'  => sub { $status->porcelain(1); },
	'quick'        => sub { $status->checksum(0); },
	'remote'       => \$remote,
	'snapshot=s'   => sub { $remote = 1; $snapshot = $_[1]; },
	'v|verbose:-1' => \&verbose,
	);
    $SIG{__WARN__} = undef;

    ($pname, $path, @err) = @_;

    if (@err) {
	error("unexpected argument '" . shift(@err) . "'");
    } elsif (defined($pname) && $pname) {
	use_profile($pname, $config);
    }

    if (!defined($path)) {
	$path = '.';
    }

    $seeker = $config->seeker();
    if (!defined($seeker)) {
	return 1;
    }

    if (lc($color) eq 'always') {
	$status->color(1);
    } elsif (lc($color) eq 'never') {
	$status->color(0);
    } elsif (lc($color) eq 'auto') {
	$status->color(-t STDOUT);
    } else {
	error("invalid color option: $color");
    }

    if ($remote) {
	if (defined($snapshot)) {
	    $config->snapshotid($snapshot);
	}

	$config->reversed(1);
	@snapshots = $config->snapshots();

	if (defined($snapshot) && scalar(@snapshots) > 1) {
	    error("more than one snapshot for id: $snapshot");
	} elsif (scalar(@snapshots) == 0) {
	    error("no matching snapshot");
	}

	$status->snapshot(shift(@snapshots));
    }

    if (defined($status->execute(\*STDOUT, $seeker, $path))) {
	return 0;
    } else {
	return 1;
    }
}

sub usage
{
    return <<"EOF";
Usage: $PROGRAM [ -h | --help ] [ -V | --version ] <command> <args...>

Backup and restore some files localy or throught ssh. The backups are
incremental and old backups can be removed.

Commands:
  help                        Print the help message for a given command.
  init                        Initialize a new backup server.
  list                        List the backups on a given server.
  send                        Make a new backup on a given server.
  recv                        Restore from a backup on a given server.

Options:
  -h, --help                  Print this help message and exit.

  -V, --version               Print the version information and exit.
EOF
}

sub version
{
    return sprintf("%s %s\n%s\n%s\n",
		   'synctl', $Synctl::VERSION,
		   $Synctl::AUTHOR, $Synctl::MAILTO);
}


sub main
{
    my ($command, @args);
    my ($main);
    
    $PROGRAM = $0;
    $PROGRAM =~ s|^.*/||;

    $SIG{__WARN__} = \&opterr;
    Getopt::Long::Configure('bundling');
    Getopt::Long::Configure('require_order');
    GetOptionsFromArray(
	\@_,
	'h|help'       => sub { printf("%s", usage()); exit (0); },
	'V|version'    => sub { printf("%s", version()); exit (0); },
	);
    $SIG{__WARN__} = undef;

    ($command, @args) = @_;
    if (!defined($command)) {
	error('missing command operand');
    }
    
    $main = $MAINS{$command};
    if (!defined($main)) {
	error("unknown command '$command'");
    }

    $COMMAND = " $command";
    Synctl::Configure(ERROR => \&syncerr);
    return $main->(@args);
}

exit (main(@ARGV));


1;
__END__
